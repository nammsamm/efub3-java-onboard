<details>
<summary>Java에서 제공하는 원시 타입들에 무엇이 있고, 각각 몇 바이트를 차지하나요?</summary>
<div markdown="1">
//
 primitive(원시)타입에는 문자형인 char(2byte), 정수형인 byte(1byte), short(2byte), int(4byte), long(8byte)가 있다. 그리고 실수형인 `float`(4byte), `double`(8byte), 논리형인 boolean(1byte)가 있다.
</div>
</details>
<br>

<details>
<summary>오버라이딩(OverRiding)과 오버로딩(OverLoading)에 대해 설명해주세요.</summary>
<div markdown="1">
// 
 - 오버로딩은 한 클래스 내에 이미 같은 이름이 같은 메소드가 있더라도 매개변수의 개수나 타입이 다르면 그 이름을 사용해서 메소드를 정의할 수 있다는 것을 의미한다. -> 다만 리턴 값만 다를 경우에는 오버로딩을 할 수 없다. 즉 매개변수의 차이로만 오버로딩을 구현할 수 있다.<br>
 - 오버라이딩은 부모 클래스에서 상속받은 메소드를 자식 클래스에서 재정의하는 것을 의미한다. 이 경우 매소드의 이름, 매개변수, 리턴값이 모두 같아야 한다.
</div>
</details>
<br>

<details>
<summary>객체지향 프로그래밍(OOP)에 대해 설명해주세요</summary>
<div markdown="1">
// 프로그래밍 패러다임 중 하나로, 프로그래밍에서 필요한 데이터를 상태와 행위를 가진 객체로 만들고, 그 객체들 간의 상호작용을 통해 로직을 구성하는 프로그래밍 방법이다. 따라서 현실 세계와 보다 비슷한 프로그래밍 방법이라고 할 수 있다. <br>
  - 장점: 코드 재사용 용이/ 유지 보수 쉬움/ 대형 프로젝트에 적합<br>
  - 단점 : 처리 속도가 상대적으로 느림/ 객체가 많으면 용량이 커짐
</div>
</details>
<br>

<details>
<summary>추상 클래스와 인터페이스에 대해 설명해주시고, 차이에 대해 설명해주세요.</summary>
<div markdown="1">
// - 추상 클래스: 추상 메소드를 이용하여 상속을 통해 자손 클래스에서 완성하도록 유도하는 클래스이다. abstract 키워드를 이용하여 구현 가능하며, 추상 클래스로는 객체를 생성할 수 없다. 추상 클래스의 기능은 자손 클래스에서 확정 및 확장되어 구현된다.<br>
  - 인터페이스 : 다른 클래스를 작성하기 위한 목적으로 작성되는데, 다중 상속이 가능하다. 인터페이스는 일반 메소드, 일반 멤버 변수를 가질 수 없다. 메소드를 작성할 경우 public abstract 로 선언해야 하고, 변수를 선언할 경우 public static final로 선언해야 하는데, 이 모두 생략 가능하다.<br>
  - 차이점: 
      추상 클래스는 extends 키워드를 사용하여 상속하며, 다중 상속은 불가능하다.<br>
      인터페이스는 inplements 키워드를 사용하여 상속하며, 다중 상속이 가능하다.<br><br>
  
      추상 클래스는 자신의 기능을 자손 클래스로 확장시킨다고 할 수 있다. <br>
      인터페이스는 인터페이스에 정의된 메소드를 각 클래스의 목적에 맞게 동일한 기능으로 구현한다고 할 수 있다.
  
</div>
</details>
<br>

<details>
<summary>가비지 컬렉션(gc)란 무엇일까요?</summary>
<div markdown="1">
// - 가비지 컬렉션이란 자바의 메모리 관리 방법 중 하나로 heap 영역에서 할당했던 메모리 영역 중 필요 없게 된 메모리 영역을 주기적으로 삭제하는 프로세스를 의미한다. 프로그래머가 수동으로 메모리 할당과 해제를 해야 하는 다른 언어와는 달리, Java는 JVM의 가미지 컬렉터가 메모리 관리를 대행해주기 때문에 개발자 입장에서는 보다 편리하다.<br>
  - 가비지 컬렉션의 단점 역시 존재한다. 우선 개발자 입장에서 메모리가 정확히 언제 해제되는지를 알 수 없다. 또 가비지 컬렉션이 작동하는 동안에는 다른 모든 동작을 멈추기 때문에 오버헤드가 발생한다.
</div>
</details>
<br>

<details>
<summary>JVM의 동작 방식에 대해 설명해 주세요.</summary>
<div markdown="1">
// 
 자바프로그램을 컴파일 해서 나온 바이트코드를 실행시켜주는 역활을 한다. 사람이 작성한 Java 코드를 실행하면 해당 코드가 바이트 코드로 컴파일된다. 
  이렇게 컴파일된 바이트 코드는 클래스 로더에서의 동적 로딩을 통해 각 런타임 영역에 할당된다. 그리고 할당된 바이트코드는 익스큐션 엔진에 의해 명령어 하나씩 실행된다.
</div>
</details>
<br>

<details>
<summary>불변 객체란 무엇이고, final은 무엇일까요? 사용하는 이유와 함께 설명해주세요.</summary>
<div markdown="1">
// 불변 객체란 객체 생성 이후 객체의 내용이 변하지 않는 객체를 의미하며, 불변성을 유지하기 위해 사용한다. 재할당은 가능하지만, 한 번 할당한 이후에는 내부의 데이터를 변경할 수 없다. 대표적으로 String, Integer, Boolean 등이 있다. <br>
 불변 객체를 이용하는 이유는 트랜잭션 내에서 객체가 변하지 않기 때문에 보다 높은 신뢰도를 가진 객체를 생성할 수 있기 때문이다. 또 생성자와 접근 메소드에 대한 방어 복사가 필요 없어지고, 멀티스레드 환경에서 동기화 처리없이 객체를 공유할 수 있다.
</div>
</details>
<br>

<details>
<summary>자바의 메모리 영역에 대해 설명해주세요.</summary>
<div markdown="1">
// method 영역, heap 영역, stack 영역으로 구분된다. <br>
  -method 영역에는 클래스 정보, 메소드 정도 또는 전역변수나 static으로 선언된 것들이 담긴다.<br>
  -heap 영역에는 new를 이용해 생성된 객체와 참조형 자료형들이 저장된다.<br>
  -stack 영역에는 기본 자료형 변수 및 일시적으로 사용되는 정보들이 저장된다.
</div>
</details>
<br>

<details>
<summary>new String()과 리터럴(" ")의 차이에 대해 설명해주세요.</summary>
<div markdown="1">
// 
 -new String()은 new를 사용하기 때문에 heap 영역에 새로운 주소가 할당된다. String의 내용이 같다고 하더라도 heap 영역에서 새로운 주소를 할당받기 때문에 String 끼리의 주소는 다르다.<br>
   -리터럴("")은 상수풀에 저장된 메모리를 확인하여 동일한 데이터가 있는 경우 주소를 참조하게 된다.
   따라서 같은 내용의 리터럴 끼리는 같은 주소를 공유한다.
</div>
</details>
<br>

<details>
<summary>⭐️ 추가 과제: 람다(lambda)에 대해 알아볼까요?</summary>
<div markdown="1">
// 
 익명함수를 의미하여 수학에서의 함수를 보다 간단하게 작성 가능하다.
</div>
</details>
<br>

<details>
<summary>⭐️ 추가 과제: 스트림(stream)에 대해 알아볼까요?</summary>
<div markdown="1">
// 
 컬렉션에 저장되어있는 엘리먼트들을 하나씩 순회하면서 처리할 수 있는 코드패턴이다.
</div>
</details>
<br>
